#-------------------------------------------------------------------------------
# General configuration
#-------------------------------------------------------------------------------
[general]


debug = False

# When `debug` is True, scanned images get shown on the screen as they get
# processed. If this is in the way, as you are debugging backend services, you
# can keep `debug` at `True` and set this value to `True` as well to get all the
# debug features but not be bothered with the images
hide_images_in_debug = False



#-------------------------------------------------------------------------------
# Configuration for where to find which binary
#-------------------------------------------------------------------------------
[programs]


# The binary to start Inkscape
inkscape = inkscape


# The binary for ImageMagick's convert
convert = convert



#-------------------------------------------------------------------------------
# Configuration for directories
#-------------------------------------------------------------------------------
[directories]


# Directory for user generated content, relative to the Scanarium repo
# root directory.
dynamic = dynamic



#-------------------------------------------------------------------------------
# Configuration for image scanning
#-------------------------------------------------------------------------------
[scan]


# Source to get images from.
#
# `cam:<n>` denotes video camera `<n>`. On linux, this resolves to
# `/dev/video<n>`. So for example, `cam:2` would be `/dev/video2`.
# `image:<file_name>` denotes the still image file `<file_name>`. This allows
# to test on systems without cameras, or inject images that arrived through
# other means (E.g.: emails)
# Strings that do not start with `cam:` or `image:` are considered raw specs to
# OpenCV's VideoCapture contstructor.
source = cam:0


# The duration below which image grabs are considered stale.
#
# For scanarium, we always want to use the image that the camera is currently
# seeing. Some camera pipelines (E.g.: GStreamer pipelines) may buffer images.
# This means that if we only scan once in a while (E.g.: When only doing manual
# scans from the Web UI, OpenCV would give the next image, which might come
# from a buffer and might have been taken immediately after the previous scan.
# So it might be several minutes old). We want to skip past such old images and
# instead want to only use fresh images. As we cannot rely on cameras giving
# proper timestamps, we instead skip on the time it took to get the image, as
# buffered images typically get `grab`-bed much quicker than fresh images.
# Images that OpenCV `grab`s quicker than `minimum_grab_time` (in seconds) are
# considered old, stable images from the buffer, while images that take at
# least `minimum_grab_time` are considered fresh images. Leaving at the
# default of 0 considers every image a fresh image. Note that this value
# should be lower than `1 / frames-per-second-of-your-camera`. Otherwise,
# you'll consider most images stale.
# For example for a 21fps camera, 0.018 gives very reliable results on a board
# that is quick enough to convert the full stream.
minimum_grab_time = 0


# Where to store raw images for debugging
#
# If not empty, it is the directory raw images get stored in for later
# debugging. This is useful to debug issues if the camera stops after some
# time without log messages. (See `raw_image_period` to specify how often an
# image is stored)
#
# If empty, raw images are not stored to disk.
#
raw_image_directory = 


# How often raw images get stored
#
# This parameter is unused, if `raw_image_directory` is empty.
#
# Otherwise, it denotes the minimal period in seconds that has to pass after
# the previous raw image store before the next raw image gets stored. Use
# `0` to store each and every image.
#
raw_image_period = 60


# Parameters for camera calibration
#
# Typical camera pictures are distorted a bit and for examlpe do not preserve
# angles. This is in the way of best detection results. To improve detection
# quality, you can calibrate your camera. Scanarium can then use this
# calibration data and make up for part of the camera distortion, which leads to
# better image detection.
#
# Either leave this value empty to perform no distortion, or set it to the
# name of an XML file holding camera calibration data from OpenCV's
# interactive camera calibration tool. See
# https://docs.opencv.org/3.2.0/d7/d21/tutorial_interactive_calibration.html
calibration_xml_file =


# Image of maximum achievable brightness
#
# If empty, no brightness correction for badly lit corners gets applied before
# contour detection.
#
# If not empty, it should point to an image that exposes the maximum achievable
# brightness for each pixel (E.g.: Cover the scanned area with white paper and
# run `./show-source.sh --store-final` and set this parameter to the stored
# file). This image gets used to clip and stretch brightness for each pixel
# before contour detection to equalize strongly and weakly lit areas of the
# scanned image.
#
# This image has to match the resolution of the camera with applied
# `calibration_xml_file`.
max_brightness = 


# Size of the window for blurring before Canny Edge Detector
#
# If your camera suffers from noise, blurring before detecting edges will give
# better detection results (and typically overall speed up things for us as
# the cost of blurring is compensated by having to comb through fewer bogus
# edges).
#
# The value to use depends on the used camera. But you can use 3 as general
# purpose starting point.
#
# 0 disables blurring.
canny_blur_size = 30


# First threshold for Canny Edge Detector
#
# This value gets used as `threshold1` in OpenCV's `Canny` implementation of
# the Canny Edge Detector. See
# https://docs.opencv.org/master/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de
canny_threshold_1 = 30


# Second threshold for Canny Edge Detector
#
# This value gets used as `threshold2` in OpenCV's `Canny` implementation of
# the Canny Edge Detector. See
# https://docs.opencv.org/master/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de
canny_threshold_2 = 400


# The white-balance filter to apply.
#
# Either `simple`, `grayworld`, or `none`.
# Since white-balance filters in some setups (E.g.: too little light) often
# distort colors of images, we do not perform white-balancing per default.
# More information about `simple` white-balancing is available at
# https://github.com/opencv/opencv_contrib/blob/master/modules/xphoto/src/simple_color_balance.cpp
# More information about `grapworld` white-balancing is available at
# https://github.com/opencv/opencv_contrib/blob/master/modules/xphoto/src/grayworld_white_balance.cpp
white_balance = none


# Whether to shrink the buffer sizes
#
# We only care about the most recent image. Buffering images makes us skip
# through the buffered images until we reach the newest one. So we generally
# want minimal buffers. However, minimizing causes some image pipelines to
# re-initialize, which may throw cameras off. So we default to `False`
# (which is save). Setting to `True` will minimize buffers.
minimize_buffers = False


# Whether to refine found corners to sub-pixel resolution
#
# Refining corners to sub-pixel resolution takes some time, but slightly
# improves accuracy for low-resolution cameras. For 720p cameras and beyond,
# the improvement is neglectible.
sub_pixel_corners = False


# Width of camera source
#
# If non-empty, force camera sources to the given width (in pixels)
# width. This is useful to force cameras to a given resolution, if
# they default to a non-optimal one.
width =


# Height of camera source
#
# If non-empty, force camera sources to the given height (in pixels)
# height. This is useful to force cameras to a given resolution, if
# they default to a non-optimal one.
height =


# Delay for frame grabbing from cameras
#
# Some cameras take some time after initialization to complete
# auto-white-balancing etc. So images grabbed early after
# initialization might be off-colour. By waiting some time, say 1
# second, such cameras allow to get way better images. The `delay`
# setting allows how specify long to wait (in seconds) before grabbing
# the frame from cameras. Leave empty for no waiting.
delay =


#-------------------------------------------------------------------------------
# Configuaration for each CGI script
#-------------------------------------------------------------------------------
[cgi]
# If not empty, use this value a DISPLAY environment variable when calling
# scripts as cgi through the webserver.  This is useful when doing remote
# debugging on a proper webserver and you want to enforce showing on a given
# display.
display =

[cgi:scan]
# Whether or not to allow calling the script as cgi through the webserver.
allow = False

[cgi:show-source]
# Whether or not to allow calling the script as cgi through the webserver.
allow = False

[cgi:regenerate-static-content]
# Whether or not to allow calling the script as cgi through the webserver.
allow = False

[cgi:reindex]
# Whether or not to allow calling the script as cgi through the webserver.
allow = False

[cgi:reset-dynamic-content]
# Whether or not to allow calling the script as cgi through the webserver.
allow = False

[cgi:dump-dynamic-config]
# Whether or not to allow calling the script as cgi through the webserver.
# This script is necessary for the frontend to work properly. So we enable it
# by default.
allow = True



#-------------------------------------------------------------------------------
# Configuaration for services
#-------------------------------------------------------------------------------



[service:continuous-scanning]

# Duration after which to exit if camera fails to produce images
#
# If the camera fails to produce after this many seconds, quit the service.
# This is useful on camera pipelines that cannot gracefully recover from
# failure on their own, but need to be fixed from the outside. Note that the
# service does not automatically get restarted after bailout. You need to use
# external measures (E.g.: systemd) to automatically restart it.
#
# 0 means no bailout, regardless how long the camera fails.
bailout_period = 0


# How to bail out
#
# Use `exit` to bail out by simply ending the program.
# Use `restart-service:FOO` to bail out by restarting service `FOO`. Note that
# restarting service `FOO` does not on it's own exit the continuous-scanning
# program.
#
# To trigger more than a single action, separate actions with `,`. So bailing
# out with mode `FOO,BAR` would first trigger bailing out `FOO` and upon
# success `BAR`.
bailout_mode = exit


# How long to wait after a bailout before allowing to trigger a new bailout
#
# This is useful for bailout modes that use a different mode than exiting the
# program, e.g.: Restarting a service. When such a bailout got triggered, the
# camera pipeline will typically take some time until it's fully operational
# again. During that recovery time, we want to pause bailout triggering, as
# we'd otherwise again and again re-trigger before the camera pipeline would
# become working again.
bailout_pause_period = 10


# How long to pause after processing an image before grabbing the next
#
# This setting is useful to lessen the load of this service. But do not make
# it too long, to avoid a laggy experience for users. Also there need to be
# at least 2 consecutive images without a QR code to allow scanning the same
# QR code afresh.
#
# This setting is measured in seconds.
image_pause_period = 0.4


# How long to pause after image grabbing errors
#
# This setting allows to give the pipeline time to recover.
#
# This setting is measured in seconds.
image_error_pause_period = 2


# Where to store state across restarts
#
# If not empty, it's taken as file name for the internal state. It's stored
# before shutdown and read at startup. This file allows to avoid considering
# a picture as new that is in front of the camera during restart.
# If empty, persisting and loading state is skipped.
state_file =



[service:demo-server]


# TCP port the demo server will listen on.
port = 8080


# The kind of requests to log
#
# Either `all` to log all requests, `non-200` to log all requests that have a
# response status different to 200, `non-2xx` to log all requests that are
# outside of the `success` range, or `none` to log no requests at all.
log_requests = all


# The value for the `Server` response header.
#
# If empty, Python's default `Server` response header is sent
server_version_override =


# The number of threads to use for serving requests
thread_pool_size = 2



#-------------------------------------------------------------------------------
# Below this line, it's standard Python logging configuration.
# By default, we log only INFO and above and we log to console.
# See https://docs.python.org/3/library/logging.config.html#logging-config-fileformat
# on how to override logging settings.

[loggers]
keys = root

[handlers]
keys = default

[formatters]
keys = default

[logger_root]
level = INFO
handlers = default
propagate = 1

[handler_default]
class=StreamHandler
formatter=default
args=(sys.stdout,)

[formatter_default]
format = %(asctime)s.%(msecs)03d %(levelname)-5s [%(threadName)s] %(filename)s:%(lineno)d - %(message)s
datefmt = %Y-%m-%dT%H:%M:%S
